# GNN Classifiers for Heterogeneous Recommendation Graphs

This section describes two Graph Neural Network architectures implemented for the movie recommendation system: GraphSAGE and Graph Convolutional Networks (GCN). Both models operate on the heterogeneous graph structure we constructed earlier.

## GraphSAGE Classifier

The GraphSAGE model implements the inductive learning approach where node embeddings are generated by sampling and aggregating features from local neighborhoods.

**Key Characteristics:**

* Inductive Learning: Can generalize to unseen nodes during training

* Neighborhood Sampling: Aggregates information from sampled neighbors

* Mean Aggregation: Uses mean pooling of neighbor features

```python
class HeteroSAGE(nn.Module):
    def __init__(
        self,
        user_feat_dim,
        movie_feat_dim,
        actor_feat_dim,
        director_feat_dim,
        genre_feat_dim,
        hidden_channels=64,
        out_channels=32
    ):
        super().__init__()

        self.user_lin = Linear(user_feat_dim, hidden_channels)
        self.movie_lin = Linear(movie_feat_dim, hidden_channels)
        self.actor_lin = Linear(actor_feat_dim, hidden_channels)
        self.director_lin = Linear(director_feat_dim, hidden_channels)
        self.genre_lin = Linear(genre_feat_dim, hidden_channels)

        self.conv1 = HeteroConv({
            ('user', 'rates', 'movie'): SAGEConv(hidden_channels, hidden_channels),
            ('movie', 'rev_rates', 'user'): SAGEConv(hidden_channels, hidden_channels),
            ('movie', 'has_genre', 'genre'): SAGEConv(hidden_channels, hidden_channels),
            ('genre', 'rev_has_genre', 'movie'): SAGEConv(hidden_channels, hidden_channels),
            ('movie', 'has_director', 'director'): SAGEConv(hidden_channels, hidden_channels),
            ('director', 'rev_has_director', 'movie'): SAGEConv(hidden_channels, hidden_channels),
            ('movie', 'has_actor', 'actor'): SAGEConv(hidden_channels, hidden_channels),
            ('actor', 'rev_has_actor', 'movie'): SAGEConv(hidden_channels, hidden_channels),
        }, aggr='sum')

        self.conv2 = HeteroConv({
            ('user', 'rates', 'movie'): SAGEConv(hidden_channels, out_channels),
            ('movie', 'rev_rates', 'user'): SAGEConv(hidden_channels, out_channels),
            ('movie', 'has_genre', 'genre'): SAGEConv(hidden_channels, out_channels),
            ('genre', 'rev_has_genre', 'movie'): SAGEConv(hidden_channels, out_channels),
            ('movie', 'has_director', 'director'): SAGEConv(hidden_channels, out_channels),
            ('director', 'rev_has_director', 'movie'): SAGEConv(hidden_channels, out_channels),
            ('movie', 'has_actor', 'actor'): SAGEConv(hidden_channels, out_channels),
            ('actor', 'rev_has_actor', 'movie'): SAGEConv(hidden_channels, out_channels),
        }, aggr='sum')

    def forward(self, x_dict, edge_index_dict):
        x_dict = {
            'user': self.user_lin(x_dict['user']),
            'movie': self.movie_lin(x_dict['movie']),
            'actor': self.actor_lin(x_dict['actor']),
            'director': self.director_lin(x_dict['director']),
            'genre': self.genre_lin(x_dict['genre']),
        }

        x_dict = self.conv1(x_dict, edge_index_dict)
        x_dict = {key: F.relu(x) for key, x in x_dict.items()}
        x_dict = self.conv2(x_dict, edge_index_dict)

        return x_dict['user'], x_dict['movie']

```

## GCN Classifier

**Key Characteristics:**

* Full Neighborhood Aggregation: Aggregates information from all immediate neighbors

* Normalized Message Passing: Uses normalized adjacency matrix for stable training


```python
class HeteroGraphConv(nn.Module):
    def __init__(self,
                 user_feat_dim,
                 movie_feat_dim,
                 actor_feat_dim,
                 director_feat_dim,
                 genre_feat_dim,
                 hidden_channels=64,
                 out_channels=32,
                 num_layers=2):
        super().__init__()

        self.hidden_channels = hidden_channels
        self.out_channels = out_channels
        self.num_layers = num_layers

        self.user_lin = Linear(user_feat_dim, hidden_channels)
        self.movie_lin = Linear(movie_feat_dim, hidden_channels)
        self.actor_lin = Linear(actor_feat_dim, hidden_channels)
        self.director_lin = Linear(director_feat_dim, hidden_channels)
        self.genre_lin = Linear(genre_feat_dim, hidden_channels)

        self.convs = nn.ModuleList()
        for i in range(num_layers):
            in_channels = hidden_channels
            out_channels_layer = out_channels if i == num_layers - 1 else hidden_channels

            conv = HeteroConv({
                ('user', 'rates', 'movie'): GraphConv(in_channels, out_channels_layer),
                ('movie', 'rev_rates', 'user'): GraphConv(in_channels, out_channels_layer),

                ('movie', 'has_genre', 'genre'): GraphConv(in_channels, out_channels_layer),
                ('genre', 'rev_has_genre', 'movie'): GraphConv(in_channels, out_channels_layer),

                ('movie', 'has_director', 'director'): GraphConv(in_channels, out_channels_layer),
                ('director', 'rev_has_director', 'movie'): GraphConv(in_channels, out_channels_layer),

                ('movie', 'has_actor', 'actor'): GraphConv(in_channels, out_channels_layer),
                ('actor', 'rev_has_actor', 'movie'): GraphConv(in_channels, out_channels_layer),
            }, aggr='sum')

            self.convs.append(conv)

        self.user_final = Linear(out_channels, out_channels)
        self.movie_final = Linear(out_channels, out_channels)

        self.reset_parameters()

    def reset_parameters(self):
        for module in self.modules():
            if isinstance(module, (nn.Linear, GraphConv)):
                module.reset_parameters()

    def forward(self, x_dict, edge_index_dict):
        x_dict = {
            'user': self.user_lin(x_dict['user']),
            'movie': self.movie_lin(x_dict['movie']),
            'actor': self.actor_lin(x_dict['actor']),
            'director': self.director_lin(x_dict['director']),
            'genre': self.genre_lin(x_dict['genre']),
        }

        for i, conv in enumerate(self.convs):
            x_dict = conv(x_dict, edge_index_dict)

            x_dict = {key: F.relu(x) for key, x in x_dict.items()}

        user_emb = self.user_final(x_dict['user'])
        movie_emb = self.movie_final(x_dict['movie'])

        return user_emb, movie_emb
```